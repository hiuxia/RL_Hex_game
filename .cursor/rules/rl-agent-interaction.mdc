---
description: "How the backend interacts with the PyTorch RL agent, clarifying code locations (active vs correct), interface, model loading, MCTS usage, and known issues."
# Apply when working with RL code (in utils or algorithm) or consumers.py
globs: ["backend/RL_Hex_game/Hex/Hexgame/utils/**.py", "backend/RL_Hex_game/algorithm/**.py", "backend/RL_Hex_game/Hex/Hexgame/consumers.py"]
alwaysApply: false
---

# RL Agent Interaction

The backend interacts with the PyTorch-based RL agent to get AI moves.

- **Currently Active Code Location:** The RL prediction logic actively imported and used by `@./backend/RL_Hex_game/Hex/Hexgame/consumers.py` is initiated via `@./backend/RL_Hex_game/Hex/Hexgame/utils/Algorithm.py`.
- **Correct/Intended Code Location:** The correct implementations for core logic reside in `@./backend/RL_Hex_game/algorithm/`:
    - `GameLogic.py`: Contains the accurate `HexGame` environment logic needed for MCTS.
    - `MCTS.py`: Contains the correct MCTS implementation.
    - `Hexmodel.py`: Contains the `HexNet` model definition (verify consistency with `utils/Hexmodel.py`).
- **Known Issue:** The MCTS logic within the `utils/` directory (if any is directly implemented there or implicitly used by `utils/Algorithm.py`) is **incorrectly implemented**. Refactoring MUST involve using `GameLogic` and `MCTS` from the `algorithm/` directory.
- **Interaction Point:** The backend (`consumers.py`'s `handle_ai_move`) calls the `predict` method of the `HexAI` class, currently instantiated from `utils/Algorithm.py`.
- **Interface (`utils/Algorithm.py` - Current):**
    - `predict(input_dict)` Input: Dictionary with `board`, `player_turn`, `last_moves`.
    - `predict(input_dict)` Output: Dictionary with `optimal_move` (`[x, y]`), `winning_rate` (0-1).
- **Required MCTS Integration:**
    - The `predict` method (or equivalent logic called by `consumers.py`) **MUST** be refactored to:
        1. Use the `HexGame` class from `@./backend/RL_Hex_game/algorithm/GameLogic.py` to represent the state accurately for the search.
        2. Use the `MCTS` class from `@./backend/RL_Hex_game/algorithm/MCTS.py`.
        3. Initialize the `MCTS` class with a **simulation count of 200** (e.g., `MCTS(model, simulations=200)`).
        4. Run `mcts.search()` using the `GameLogic` state.
        5. Determine the `optimal_move` based on MCTS results.
- **Model Definition:** The `HexNet` definition likely exists in both `utils/Hexmodel.py` and `algorithm/Hexmodel.py`. The version in `algorithm/` should be considered canonical unless analysis proves otherwise.
- **Model Loading:**
    - The `HexAI` class in `utils/Algorithm.py` currently loads the `.pth` model.
    - **CRITICAL ISSUE:** The file path is **hardcoded**. This MUST be made configurable (goal #1 in `refactoring-goals.mdc`).
- **Dependencies:** PyTorch, NumPy.
